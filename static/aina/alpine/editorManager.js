export default (slug, initialData = {}) => ({
    slug: slug,
    isProcessing: false,
    statusText: 'Ready',
    editors: { html: null, css: null },
    copiedPrompt: false,
    
    // Config for compilation
    sysConfig: { // Will be generated by setting, for now hardcoded
        head: `
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
        `,
        defaultHtml: `<div class="p-10">\n  <h1 class="text-3xl font-bold text-blue-600">New Page</h1>\n  <p>Start editing...</p>\n</div>`,
        defaultCss: `body { background-color: #f3f4f6; }`
    },

    async init() {
        // 1. Initialize HTML Editor
        this.editors.html = window.AceService.init(
            this.$refs.htmlEditor, 
            'html', 
            initialData.html || this.sysConfig.defaultHtml
        );

        // 2. Initialize CSS Editor
        this.editors.css = window.AceService.init(
            this.$refs.cssEditor, 
            'css', 
            initialData.css || this.sysConfig.defaultCss
        );

        // 3. Initial Render from Server
        await this.fetchAndRender();
    },

    /**
     * ACTION 1: Run / Sync
     * 1. Updates 'custom.builder' on server (Source code).
     * 2. Calls fetchAndRender() to get that truth back and compile it.
     * Note: This DOES NOT update the public 'html' field.
     */
    async syncAndRender() {
        this.isProcessing = true;
        this.statusText = 'Syncing...';

        const userHtml = this.editors.html.getValue();
        const userCss = this.editors.css.getValue();

        // 1. Network Call (Get Script) - We still need this to mix in generator data
        const currentScript = (await this.$api.aina.get(this.slug).execute())?.custom?.builder?.script || "";

        // 2. Network Call (Save in Background!)
        const payload = {
            custom: {
                builder: {
                    head: this.sysConfig.head,
                    content: userHtml,
                    style: userCss,
                    script: currentScript
                }
            }
        };
        
        // START saving, but don't await it for the preview!
        const savePromise = this.$api.aina.updateHTML().execute(this.slug, payload);

        // 3. Render IMMEDIATELY using local variables
        const finalHtml = this.compilePage(userHtml, userCss, currentScript);
        this.$refs.previewFrame.srcdoc = finalHtml;
        
        // Now await the save just to update the "Saved" status text
        try {
            await savePromise;
            this.statusText = 'Saved';
        } catch (e) {
            this.statusText = 'Save Failed';
        }
        
        this.isProcessing = false;
    },

    async getPrompt() {
        // Use current editor values so the prompt reflects unsaved changes
        const userHtml = this.editors.html.getValue();
        const userCss = this.editors.css.getValue();
        
        // We still fetch the script since it's managed separately
        const response = await this.$api.aina.get(this.slug).execute();
        const currentScript = response?.custom?.builder?.script || "";
        
        const finalHtml = this.compilePage(userHtml, userCss, currentScript);
        
        return `Your task is to create a UI based on the given template.

You can only write html and styles, you may not write scripts, use the already given script if any.
You must use Alpine for interactivity (no need to import Alpine as it's already imported.)
You cannot modify the head.

The head contains:
- FontsAwesome
- Tailwind

Here is the current state:
---
${finalHtml}
---

Your task is: [TASK HERE]`;
    },

    async copyPrompt() {
        try {
            const text = await this.getPrompt();
            await navigator.clipboard.writeText(text);
            
            // Visual feedback
            this.copiedPrompt = true;
            this.statusText = 'Prompt Copied!';
            
            setTimeout(() => {
                this.copiedPrompt = false;
                this.statusText = 'Ready';
            }, 2000);
        } catch (err) {
            console.error('Failed to copy prompt', err);
            this.statusText = 'Copy Failed';
        }
    },

    /**
     * ACTION 2: Deploy
     * Compiles the current editor state into a full HTML string
     * and saves it to the 'html' field on the server.
     */
    async deployHtml() {
        this.isProcessing = true;
        this.statusText = 'Deploying...';
        const response = await this.$api.aina.get(this.slug).execute();
        const builderData = response.custom?.builder || {};
        const script = builderData.script || ""

        const userHtml = this.editors.html.getValue();
        const userCss = this.editors.css.getValue();
        const generatedJs = script
        
        // Compile locally just for the payload construction
        const fullCompiledHtml = this.compilePage(userHtml, userCss, generatedJs);

        const payload = {
            html: fullCompiledHtml
        };

        try {
            await this.$api.aina.updateHTML().execute(this.slug, payload);
            
            this.$store.notifications.add({
                type: 'success',
                title: 'Deployed',
                message: 'Public HTML has been updated.'
            });
            this.statusText = 'Deployed';
        } catch (error) {
            console.error("Deploy error:", error);
            this.$store.notifications.add({ type: 'error', message: 'Deployment failed.' });
            this.statusText = 'Error';
        } finally {
            this.isProcessing = false;
        }
    },

    /**
     * Fetches the page object from server, extracts builder data,
     * compiles it, and updates the iframe.
     */
    async fetchAndRender() {
        try {
            // 1. GET request (Single Source of Truth)
            const response = await this.$api.aina.get(this.slug).execute();
            
            // 2. Extract Data (fallback to current editor values if server is empty/new)
            const builderData = response.custom?.builder || {};
            
            const content = builderData.content || this.editors.html.getValue();
            const style = builderData.style || this.editors.css.getValue();
            const script = builderData.script || ""

            if (content) {
                this.editors.html.setValue(content, -1);
            }
                
            if (style) {
                this.editors.css.setValue(style, -1);
            }

            // 3. Compile everything together
            const finalHtml = this.compilePage(content, style, script);

            // 4. Update Iframe
            if (this.$refs.previewFrame) {
                this.$refs.previewFrame.srcdoc = finalHtml;
            }
        } catch (error) {
            console.error("Fetch render error:", error);
        }
    },

    /**
     * Helper to combine Head, Style, and Body
     */
    compilePage(htmlContent, cssContent, jsContent) {
        const result = `<!DOCTYPE html>
<html>
    <head>
        ${this.sysConfig.head}
        <style type="text/tailwindcss">${cssContent}</style>
    </head>
    <body>
        ${htmlContent}
        <script type="module" src="/static/hikarin/main.js"></script>
        <script>
        ${jsContent}
        </script>
    </body>
</html>`
        console.log(result)
        return result;
    },
});